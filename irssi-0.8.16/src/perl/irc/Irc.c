/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Irc.xs. Do not edit this file, edit Irc.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Irc.xs"
#include "module.h"

static int initialized = FALSE;

static void perl_irc_connect_fill_hash(HV *hv, IRC_SERVER_CONNECT_REC *conn)
{
	perl_connect_fill_hash(hv, (SERVER_CONNECT_REC *) conn);
	hv_store(hv, "alternate_nick", 14, new_pv(conn->alternate_nick), 0);
}

static void perl_irc_server_fill_hash(HV *hv, IRC_SERVER_REC *server)
{
       	perl_server_fill_hash(hv, (SERVER_REC *) server);

       	hv_store(hv, "real_address", 12, new_pv(server->real_address), 0);
       	hv_store(hv, "usermode", 8, new_pv(server->usermode), 0);
       	hv_store(hv, "userhost", 8, new_pv(server->userhost), 0);

	hv_store(hv, "max_cmds_at_once", 16, newSViv(server->max_cmds_at_once), 0);
	hv_store(hv, "cmd_queue_speed", 15, newSViv(server->cmd_queue_speed), 0);
	hv_store(hv, "max_query_chans", 15, newSViv(server->max_query_chans), 0);

	hv_store(hv, "max_kicks_in_cmd", 16, newSViv(server->max_kicks_in_cmd), 0);
	hv_store(hv, "max_msgs_in_cmd", 15, newSViv(server->max_msgs_in_cmd), 0);
	hv_store(hv, "max_modes_in_cmd", 16, newSViv(server->max_modes_in_cmd), 0);
	hv_store(hv, "max_whois_in_cmd", 16, newSViv(server->max_whois_in_cmd), 0);
	hv_store(hv, "isupport_sent", 13, newSViv(server->isupport_sent), 0);
}

static void perl_ban_fill_hash(HV *hv, BAN_REC *ban)
{
	hv_store(hv, "ban", 3, new_pv(ban->ban), 0);
	hv_store(hv, "setby", 5, new_pv(ban->setby), 0);
	hv_store(hv, "time", 4, newSViv(ban->time), 0);
}

static void perl_dcc_fill_hash(HV *hv, DCC_REC *dcc)
{
	hv_store(hv, "type", 4, new_pv(dcc_type2str(dcc->type)), 0);
	hv_store(hv, "orig_type", 9, new_pv(dcc_type2str(dcc->orig_type)), 0);
	hv_store(hv, "created", 7, newSViv(dcc->created), 0);

	hv_store(hv, "server", 6, iobject_bless(dcc->server), 0);
	hv_store(hv, "servertag", 9, new_pv(dcc->servertag), 0);
	hv_store(hv, "mynick", 6, new_pv(dcc->mynick), 0);
	hv_store(hv, "nick", 4, new_pv(dcc->nick), 0);

	hv_store(hv, "chat", 4, simple_iobject_bless(dcc->chat), 0);
	hv_store(hv, "target", 6, new_pv(dcc->target), 0);
	hv_store(hv, "arg", 3, new_pv(dcc->arg), 0);

	hv_store(hv, "addr", 4, new_pv(dcc->addrstr), 0);
	hv_store(hv, "port", 4, newSViv(dcc->port), 0);

	hv_store(hv, "starttime", 9, newSViv(dcc->starttime), 0);
	hv_store(hv, "transfd", 7, newSViv(dcc->transfd), 0);
}

static void perl_dcc_chat_fill_hash(HV *hv, CHAT_DCC_REC *dcc)
{
        perl_dcc_fill_hash(hv, (DCC_REC *) dcc);

	hv_store(hv, "id", 2, new_pv(dcc->id), 0);
	hv_store(hv, "mirc_ctcp", 9, newSViv(dcc->mirc_ctcp), 0);
	hv_store(hv, "connection_lost", 15, newSViv(dcc->connection_lost), 0);
}

static void perl_dcc_file_fill_hash(HV *hv, FILE_DCC_REC *dcc)
{
        perl_dcc_fill_hash(hv, (DCC_REC *) dcc);

	hv_store(hv, "size", 4, newSViv(dcc->size), 0);
	hv_store(hv, "skipped", 7, newSViv(dcc->skipped), 0);
}

static void perl_dcc_get_fill_hash(HV *hv, GET_DCC_REC *dcc)
{
        perl_dcc_file_fill_hash(hv, (FILE_DCC_REC *) dcc);

	hv_store(hv, "get_type", 8, newSViv(dcc->get_type), 0);
	hv_store(hv, "file", 4, new_pv(dcc->file), 0);
	hv_store(hv, "file_quoted", 11, newSViv(dcc->file_quoted), 0);
}

static void perl_dcc_send_fill_hash(HV *hv, SEND_DCC_REC *dcc)
{
        perl_dcc_file_fill_hash(hv, (FILE_DCC_REC *) dcc);

	hv_store(hv, "file_quoted", 11, newSViv(dcc->file_quoted), 0);
	hv_store(hv, "waitforend", 10, newSViv(dcc->waitforend), 0);
	hv_store(hv, "gotalldata", 10, newSViv(dcc->gotalldata), 0);
}

static void perl_netsplit_fill_hash(HV *hv, NETSPLIT_REC *netsplit)
{
        AV *av;
        GSList *tmp;

	hv_store(hv, "nick", 4, new_pv(netsplit->nick), 0);
	hv_store(hv, "address", 7, new_pv(netsplit->address), 0);
	hv_store(hv, "destroy", 7, newSViv(netsplit->destroy), 0);

	hv_store(hv, "server", 6,
		 plain_bless(netsplit->server,
			     "Irssi::Irc::Netsplitserver"), 0);

	av = newAV();
	for (tmp = netsplit->channels; tmp != NULL; tmp = tmp->next) {
		av_push(av, plain_bless(tmp->data,
					"Irssi::Irc::Netsplitchannel"));
	}
	hv_store(hv, "channels", 8, newRV_noinc((SV*)av), 0);
}

static void perl_netsplit_server_fill_hash(HV *hv, NETSPLIT_SERVER_REC *rec)
{
	hv_store(hv, "server", 6, new_pv(rec->server), 0);
	hv_store(hv, "destserver", 10, new_pv(rec->destserver), 0);
	hv_store(hv, "count", 5, newSViv(rec->count), 0);
}

static void perl_netsplit_channel_fill_hash(HV *hv, NETSPLIT_CHAN_REC *rec)
{
	hv_store(hv, "name", 4, new_pv(rec->name), 0);
	hv_store(hv, "op", 2, newSViv(rec->op), 0);
	hv_store(hv, "halfop", 6, newSViv(rec->halfop), 0);
	hv_store(hv, "voice", 5, newSViv(rec->voice), 0);
}

static void perl_notifylist_fill_hash(HV *hv, NOTIFYLIST_REC *notify)
{
	AV *av;
	char **tmp;

	hv_store(hv, "mask", 4, new_pv(notify->mask), 0);
	hv_store(hv, "away_check", 10, newSViv(notify->away_check), 0);

	av = newAV();
	if (notify->ircnets != NULL) {
		for (tmp = notify->ircnets; *tmp != NULL; tmp++) {
			av_push(av, new_pv(*tmp));
		}
	}
	hv_store(hv, "ircnets", 7, newRV_noinc((SV*)av), 0);
}

static void perl_client_fill_hash(HV *hv, CLIENT_REC *client)
{
	hv_store(hv, "nick", 4, new_pv(client->nick), 0);
	hv_store(hv, "host", 4, new_pv(client->host), 0);
	hv_store(hv, "proxy_address", 13, new_pv(client->proxy_address), 0);
	hv_store(hv, "server", 6, iobject_bless(client->server), 0);
	hv_store(hv, "pass_sent", 9, newSViv(client->pass_sent), 0);
	hv_store(hv, "user_sent", 9, newSViv(client->user_sent), 0);
	hv_store(hv, "connected", 9, newSViv(client->connected), 0);
	hv_store(hv, "want_ctcp", 9, newSViv(client->want_ctcp), 0);
	hv_store(hv, "ircnet", 6, new_pv(client->listen->ircnet), 0);
}

static PLAIN_OBJECT_INIT_REC irc_plains[] = {
	{ "Irssi::Irc::Ban", (PERL_OBJECT_FUNC) perl_ban_fill_hash },
	{ "Irssi::Irc::Dcc", (PERL_OBJECT_FUNC) perl_dcc_fill_hash },
	{ "Irssi::Irc::Netsplit", (PERL_OBJECT_FUNC) perl_netsplit_fill_hash },
	{ "Irssi::Irc::Netsplitserver", (PERL_OBJECT_FUNC) perl_netsplit_server_fill_hash },
	{ "Irssi::Irc::Netsplitchannel", (PERL_OBJECT_FUNC) perl_netsplit_channel_fill_hash },
	{ "Irssi::Irc::Notifylist", (PERL_OBJECT_FUNC) perl_notifylist_fill_hash },
	{ "Irssi::Irc::Client", (PERL_OBJECT_FUNC) perl_client_fill_hash },

	{ NULL, NULL }
};

#line 182 "Irc.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 234 "Irc.c"

XS(XS_Irssi__Irc_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Irssi__Irc_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 179 "Irc.xs"
	int chat_type;
#line 249 "Irc.c"
#line 181 "Irc.xs"
	if (initialized) return;
	perl_api_version_check("Irssi::Irc");
	initialized = TRUE;

	chat_type = chat_protocol_lookup("IRC");

	irssi_add_object(module_get_uniq_id("SERVER CONNECT", 0),
			 chat_type, "Irssi::Irc::Connect",
			 (PERL_OBJECT_FUNC) perl_irc_connect_fill_hash);
	irssi_add_object(module_get_uniq_id("SERVER", 0),
			 chat_type, "Irssi::Irc::Server",
			 (PERL_OBJECT_FUNC) perl_irc_server_fill_hash);
	irssi_add_object(module_get_uniq_id_str("DCC", "CHAT"),
			 0, "Irssi::Irc::Dcc::Chat",
			 (PERL_OBJECT_FUNC) perl_dcc_chat_fill_hash);
	irssi_add_object(module_get_uniq_id_str("DCC", "GET"),
			 0, "Irssi::Irc::Dcc::Get",
			 (PERL_OBJECT_FUNC) perl_dcc_get_fill_hash);
	irssi_add_object(module_get_uniq_id_str("DCC", "SEND"),
			 0, "Irssi::Irc::Dcc::Send",
			 (PERL_OBJECT_FUNC) perl_dcc_send_fill_hash);
	irssi_add_object(module_get_uniq_id_str("DCC", "SERVER"),
			 0, "Irssi::Irc::Dcc::Server",
			 (PERL_OBJECT_FUNC) perl_dcc_send_fill_hash);
        irssi_add_plains(irc_plains);
	perl_eval_pv("@Irssi::Irc::Dcc::Chat::ISA = qw(Irssi::Irc::Dcc);\n"
		     "@Irssi::Irc::Dcc::Get::ISA = qw(Irssi::Irc::Dcc);\n"
		     "@Irssi::Irc::Dcc::Send::ISA = qw(Irssi::Irc::Dcc);\n"
		     "@Irssi::Irc::Dcc::Server::ISA = qw(Irssi::Irc::Dcc);\n",
		     TRUE);
#line 281 "Irc.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Irssi__Irc_deinit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Irssi__Irc_deinit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 215 "Irc.xs"
	initialized = FALSE;
#line 300 "Irc.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Irssi__Irc); /* prototype to pass -Wmissing-prototypes */
XS(boot_Irssi__Irc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Irssi::Irc::init", XS_Irssi__Irc_init, file, "");
        (void)newXSproto_portable("Irssi::Irc::deinit", XS_Irssi__Irc_deinit, file, "");

    /* Initialisation Section */

#line 218 "Irc.xs"
	irssi_boot(Irc__Channel);
	irssi_boot(Irc__Ctcp);
	irssi_boot(Irc__Dcc);
	irssi_boot(Irc__Modes);
	irssi_boot(Irc__Netsplit);
	irssi_boot(Irc__Notifylist);
	irssi_boot(Irc__Query);
	irssi_boot(Irc__Server);
	irssi_boot(Irc__Client);

#line 345 "Irc.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

